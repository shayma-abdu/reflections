What happens when you initailize a repository? why do you need to di it?

meta files that contain description of the repository are created.

How is the staging area different from the working directory and the repository? what value do you think it offers?

Its a temprory area that holds the data and collects the data that the user wants to commit from the working directory and to the repository. This is to help make more logical and compact commits. 

How can you use the staging area to make sure you have one commit per logical change?

the user can choose to add files that are within the same logical change to the staging area, and choose to commit those in one commit. 

What are some situations when branches would be helpful in keeping your history organized? How would branches help?

When adding a new experimental piece of code or a completely new direction, that you are not still not sure you want in the long run. branches, help to keep these experimental or new directions in a different area from the main function master code. helping the programmers to freally try out new directions without the fear of affecting the main functioning master code.

How do the diagrams help you visualize the branch structure?

It shows a simplified version of different branches, and how they are connected. giving us a clearer look into log of each branch and the reachability status of each commit.

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

the two final commits from the two branches are merged together into one commit. and this final commit has refrence to its two parents, making it possible to reach previous commits in the two branches. we represent it as two linear branches with each commit having a refrence to one parent, and when the two branches merge, the final merged commit will be represented by a node that has two branches (parent commits) coming out of it.

What are the pros and cons of Git's automatic merging vs. always doing merges manually?

pros: Its less time consuming, and easier to deal with
cons: There could be a conflict that git deals with in an unoptimal way. leading to problems in the future. as opposed to asking the programmers for the best way they find suitable to deal with the merge.
end